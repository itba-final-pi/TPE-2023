#undef NDEBUG

#include <stdlib.h>
#include <stdio.h>
#include <assert.h>

#include "tests.h"

#include "BinaryTree.h"

/**
 * Stacks store **pointers** 
 * 
 * To test this simply, we cast integers (10, 20, 30) to void pointers
 * 
 * So that we can validate the pointers to those memory addresses (that we don't technically own) are stored properly
 * 
 * i.e:
 * push(s, (void*) 10)
 * pop(s) // returns (void *) 10
 */

int
main(void) {
    BinaryTree tree = newBinaryTree();
    int value = 42;

    assert( search(tree, 10) == NULL );

    insert(tree, 10, (void *) 10 );
    insert(tree, 20, (void *) 20);
    insert(tree, 30, (void *) 30);
    insert(tree, 40, (void *) 40);

    assert( getNodeKey(getBinaryTreeRoot(tree)) == 20 );
    assert( getNodeKey(getLeftNode(getBinaryTreeRoot(tree))) == 10 );
    assert( getNodeKey(getRightNode(getBinaryTreeRoot(tree))) == 30 );
    assert( getNodeKey(getRightNode(getRightNode(getBinaryTreeRoot(tree)))) == 40 );

    insert(tree, 50, (void *) 50);
    assert( getNodeKey(getRightNode(getBinaryTreeRoot(tree))) == 40 );

    insert(tree, 25, &value);

    assert( getNodeKey(getBinaryTreeRoot(tree)) == 30 );
    assert( getNodeKey(getLeftNode(getBinaryTreeRoot(tree))) == 20 );
    assert( getNodeKey(getRightNode(getBinaryTreeRoot(tree))) == 40 );
    assert( getNodeKey(getRightNode(getLeftNode(getBinaryTreeRoot(tree)))) == 25 );

    assert( search(tree, 10) == (void *) 10 );
    assert( search(tree, 25) == (void *) &value );

    toBeginTreeIter(tree);

    void * tree_inorder[] = { (void *) 10, (void *) 20, (void *) &value, (void *) 30, (void *) 40, (void *) 50 };

    for (int i = 0; hasNextTreeElem(tree); i++) {
        void * p = (void *) getNextTreeElem(tree);
        assert( (void *)p == tree_inorder[i] );
    }

    freeBinaryTree(tree);

    // Try creating a really large binary tree with loads of keys
    int ARRAY[] = { 1209, 936, 1195, 350, 696, 550, 1286, 1084, 31, 393, 926, 1046, 1147, 556, 297, 470, 280, 1136, 302, 1292, 502, 173, 663, 162, 324, 429, 200, 785, 1210, 675, 1216, 1226, 385, 236, 935, 79, 1225, 451, 463, 652, 430, 595, 1202, 626, 1200, 436, 884, 1011, 183, 382, 206, 186, 957, 972, 479, 328, 329, 1165, 604, 1298, 1257, 235, 628, 763, 634, 414, 452, 580, 167, 922, 175, 613, 1145, 838, 226, 701, 507, 439, 841, 549, 218, 1096, 608, 907, 959, 585, 578, 125, 244, 161, 1217, 552, 940, 288, 970, 273, 196, 913, 1231, 279, 126, 294, 559, 703, 179, 1023, 321, 144, 464, 190, 788, 684, 982, 527, 1062, 1299, 1229, 408, 553, 405, 1087, 762, 704, 646, 571, 1157, 1184, 453, 224, 1091, 1073, 930, 1153, 690, 1244, 842, 293, 1287, 1111, 636, 761, 537, 901, 1237, 656, 166, 1255, 221, 1103, 1213, 434, 250, 1108, 13, 1246, 1194, 47, 1199, 438, 1223, 377, 601, 945, 1265, 323, 651, 977, 630, 1088, 966, 1130, 184, 268, 610, 314, 1212, 138, 326, 395, 658, 969, 370, 687, 1139, 100, 1158, 582, 339, 232, 928, 572, 285, 693, 1254, 208, 1142, 1192, 1151, 659, 846, 489, 222, 581, 351, 1289, 956, 1180, 858, 247, 111, 1236, 1054, 257, 851, 233, 487, 544, 311, 1134, 407, 227, 512, 229, 1119, 589, 1013, 378, 535, 148, 150, 1191, 623, 1025, 1027, 89, 864, 999, 409, 1124, 259, 941, 331, 772, 192, 629, 523, 201, 1248, 132, 354, 197, 491, 639, 985, 757, 1037, 533, 943, 880, 394, 995, 965, 255, 433, 1109, 644, 467, 415, 1266, 758, 1042, 1016, 1031, 974, 137, 778, 783, 1026, 1065, 292, 1173, 602, 619, 1206, 551, 341, 237, 951, 860, 1019, 665, 1295, 359, 153, 274, 1009, 217, 256, 344, 142, 1044, 682, 207, 242, 575, 780, 664, 1034, 230, 590, 202, 1053, 348, 546, 689, 1163, 480, 514, 1050, 865, 437, 964, 258, 1138, 143, 36, 1043, 420, 169, 1164, 296, 921, 1121, 298, 1126, 228, 472, 447, 989, 660, 60, 1099, 759, 431, 1041, 611, 317, 1105, 984, 253, 92, 614, 1264, 677, 1068, 1201, 1291, 352, 555, 1074, 1122, 1238, 1048, 963, 435, 189, 383, 176, 1129, 764, 193, 641, 501, 869, 1128, 542, 1154, 496, 1092, 515, 506, 388, 185, 485, 962, 1100, 151, 1112, 616, 750, 86, 239, 1125, 270, 1002, 968, 392, 316, 1233, 493, 403, 406, 1208, 835, 1033, 586, 767, 1058, 1193, 615, 379, 1127, 517, 1222, 1066, 786, 511, 78, 600, 592, 312, 401, 423, 881, 1095, 845, 231, 372, 418, 606, 211, 1197, 346, 1261, 852, 481, 784, 9, 1283, 366, 588, 1032, 1079, 635, 264, 1063, 140, 419, 205, 145, 911, 769, 315, 1253, 1232, 1055, 1221, 986, 215, 441, 1086, 751, 76, 283, 152, 705, 1024, 322, 410, 261, 666, 336, 579, 1284, 495, 400, 396, 1196, 343, 565, 1093, 558, 327, 384, 1021, 1117, 1040, 471, 583, 443, 337, 971, 65, 1094, 598, 1174, 509, 948, 1004, 1203, 267, 461, 442, 120, 591, 650, 304, 497, 412, 1273, 358, 474, 749, 519, 129, 955, 398, 946, 557, 781, 1059, 1071, 752, 33, 375, 645, 260, 303, 275, 528, 455, 1090, 432, 240, 1250, 488, 993, 1245, 149, 680, 1182, 284, 199, 1167, 155, 159, 862, 924, 318, 1294, 99, 291, 289, 1242, 1218, 597, 1240, 866, 587, 1278, 1288, 891, 570, 1007, 1057, 1176, 1166, 272, 912, 1215, 647, 1070, 1178, 1150, 456, 1227, 1293, 914, 1263, 753, 389, 834, 330, 490, 299, 325, 548, 468, 897, 367, 1085, 21, 1056, 450, 980, 469, 271, 594, 1131, 223, 1047, 520, 373, 1102, 932, 934, 182, 909, 1156, 983, 929, 281, 676, 413, 1106, 895, 669, 1239, 444, 1260, 1101, 498, 361, 1185, 248, 564, 976, 122, 286, 203, 691, 566, 952, 262, 1187, 483, 1149, 547, 1220, 1110, 782, 191, 172, 1235, 369, 887, 449, 855, 387, 1107, 243, 910, 906, 918, 1249, 532, 574, 563, 477, 668, 892, 1181, 1282, 160, 306, 942, 878, 445, 931, 888, 538, 524, 1104, 944, 569, 994, 1152, 1285, 840, 568, 950 };
    int size = sizeof(ARRAY)/sizeof(*ARRAY);

    tree = newBinaryTree();

    for (int i = 0; i < size; i++) {
        insert(tree, ARRAY[i], NULL);
    }

    insert(tree, 938, (void *) 938 );

    assert(search(tree, 938) == (void *) 938);
    
    freeBinaryTree(tree);

    return 0;
}
